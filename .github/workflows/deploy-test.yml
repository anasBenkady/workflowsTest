name: Publish Packages to Verdaccio

on:
  push:
    branches:
      - development

jobs:
  find_packages:
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.dependencies-step.outputs.package }}
      dependencies-map: ${{ steps.dependencies-step.outputs.dependencies-map }}
    steps:
      - uses: actions/checkout@v3

      - id: dependencies-step
        name: Finding packages and their dependencies in shared libraries
        run: |
            echo "Finding package.json files..."
            PACKAGES=$(find . -name 'package.json' -not -path '*/node_modules/*')

            PACKAGES_JSON=$(echo "$PACKAGES" | sed 's#/package.json##' | jq -R -s -c 'split("\n")[:-1]')
            echo "Found packages = $PACKAGES_JSON"
            echo "package=$PACKAGES_JSON" >> $GITHUB_OUTPUT

            PACKAGE_NAMES=()
            PACKAGE_PATHS_MAP="{}"

            for PACKAGE in $PACKAGES; do
                # Extract the name field from the package.json file
                if [ -f "$PACKAGE" ]; then
                    NAME=$(jq -r '.name' "$PACKAGE" | tr -d '\n' | tr -d '\r')
                    if [ "$NAME" != "null" ]; then
                        PACKAGE_NAME=$(jq -r '.name' "$PACKAGE")
                        PACKAGE_NAMES+=("$PACKAGE_NAME")
                        PACKAGE_PATH=$(echo $PACKAGE | sed 's|/package.json||')
                        PACKAGE_PATHS_MAP=$(echo $PACKAGE_PATHS_MAP | jq --arg name "$PACKAGE_NAME" --arg path "$PACKAGE_PATH" '. + {($name): $path}')
                    fi
                fi
            done

            PACKAGE_NAMES_JSON=$(printf '%s\n' "${PACKAGE_NAMES[@]}" | jq -R -s -c 'split("\n")[:-1]')

            DEPENDENCIES_MAP="{"
            for PACKAGE in $PACKAGES; do
                if [ -f "$PACKAGE" ]; then
                    # Filter and collect dependencies that are in the PACKAGE_NAMES_JSON
                    FILTERED_DEPS=$(jq -r --argjson packageNames "$PACKAGE_NAMES_JSON" --argjson pathsMap "$PACKAGE_PATHS_MAP" \
                        '.dependencies | to_entries | map(select(.key as $k | $packageNames | index($k))) | map($pathsMap[.key] // "") | map(select(. != "")) | map("\"" + . + "\"") | join(",")' "$PACKAGE")
                    
                    # Format the output to match the required structure
                    if [[ $FILTERED_DEPS != "" ]]; then
                        DEPENDENCIES_MAP+="\"$(echo $PACKAGE | sed 's|/package.json||')\":[$FILTERED_DEPS],"
                    else
                        DEPENDENCIES_MAP+="\"$(echo $PACKAGE | sed 's|/package.json||')\":[],"
                    fi
                fi
            done
            DEPENDENCIES_MAP=${DEPENDENCIES_MAP%,}
            DEPENDENCIES_MAP+="}"

            echo "dependencies map = $DEPENDENCIES_MAP"
            echo "dependencies-map=$DEPENDENCIES_MAP" >> $GITHUB_OUTPUT
        shell: bash

  order_packages:
    needs: find_packages
    runs-on: ubuntu-latest
    env:
      json_packages: ${{ needs.find_packages.outputs.packages }}
      json_dependencies: ${{ needs.find_packages.outputs.dependencies-map }}
    outputs:
        ordered-packages: ${{ steps.ordered-packages.outputs.ordered-packages }}
    steps:
      - uses: actions/checkout@v3

      - id: ordered-packages
        name: Ordering the packages array
        run: | 
          mapfile -t PACKAGES < <(echo $json_packages | jq -r '.[]')

          # Declare associative array for dependencies
          declare -A DEPENDENCIES_MAP

          for pkg in "${PACKAGES[@]}"; do
              # Extract dependencies for the package
              dependencies=$(echo $json_dependencies | jq -r --arg pkg "$pkg" '.[$pkg] | @csv' | tr -d '"')

              IFS=',' read -r -a deps <<< "$dependencies"
              for dep in "${deps[@]}"; do
                  if [[ -n "$dep" ]]; then
                      DEPENDENCIES_MAP["$pkg,$dep"]=1
                  fi
              done
          done

          # Topological sort function
          function tsort() {
              local -a nodes=("${!DEPENDENCIES_MAP[@]}")
              local -A in_degree
              local -a result

              for pkg in "${PACKAGES[@]}"; do
                  in_degree[$pkg]=0
              done

              for node in "${nodes[@]}"; do
                  IFS=',' read -r src dst <<< "$node"
                  ((in_degree[$dst]++))
              done

              local -a queue
              for pkg in "${PACKAGES[@]}"; do
                  if [[ ${in_degree[$pkg]} -eq 0 ]]; then
                      queue+=("$pkg")
                  fi
              done

              while [[ ${#queue[@]} -gt 0 ]]; do
                  local node="${queue[0]}"
                  queue=("${queue[@]:1}")
                  result=("$node" "${result[@]}")  
                  for edge in "${nodes[@]}"; do
                      IFS=',' read -r src dst <<< "$edge"
                      if [[ $src == "$node" ]]; then
                          ((in_degree[$dst]--))
                          if [[ ${in_degree[$dst]} -eq 0 ]]; then
                              queue+=("$dst")
                          fi
                      fi
                  done
              done

              echo "${result[@]}"
          }

          # Perform the topological sort
          sorted_packages=$(tsort)
          formatted_json=$(echo "$sorted_packages" | jq -R 'split(" ") | map(select(length > 0))' | jq -c)

          echo "Ordered packages installation:"
          echo "$formatted_json"

          echo "ordered-packages=$(echo "$formatted_json")" >> $GITHUB_OUTPUT

  publish-to-verdaccio:
    needs: order_packages
    runs-on: ubuntu-latest
    environment: Dev
    env:
      packages_json: ${{ needs.order_packages.outputs.ordered-packages }}
    steps:
      - uses: actions/checkout@v3

      - name: Publish packages in order to Verdaccio
        run: |
          readarray -t packages < <(echo $packages_json | jq -r '.[]')

          # Iterate over each package
          for PACKAGE in "${packages[@]}"; do
            echo "*************** Processing package in directory $PACKAGE ***************"
            
            echo "*************** Navigate into the package directory..."
            cd $PACKAGE

            echo "*************** Configure npm registry..." 
            echo "registry=http://${{ secrets.VERDACCIO_REGISTRY }}/" > .npmrc
            echo "//${{ secrets.VERDACCIO_REGISTRY }}/:_authToken=\"${{ secrets.VERDACCIO_TOKEN }}\"" >> .npmrc

            echo ""*************** Unpublish existing package version..."
            npm unpublish --force || true  # Use || to handle potential failure gracefully

            echo ""*************** Install package dependencies..."
            npm install
            
            echo ""*************** Publish the package to Verdaccio..."
            npm publish
            
            echo ""*************** Navigate back to the root directory..."
            cd -

            echo
            echo
          done
        shell: bash
