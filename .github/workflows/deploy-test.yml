name: Publish Packages to Verdaccio

on:
  push:
    branches:
      - development

jobs:
  find_packages:
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.dependencies-step.outputs.package }}
      dependencies-map: ${{ steps.dependencies-step.outputs.dependencies-map }}
    steps:
      - uses: actions/checkout@v3

      - id: dependencies-step
        name: Finding packages and their dependencies in shared libraries
        run: |
            echo "Finding package.json files..."
            # Find all package.json files, excluding those in node_modules directories
            PACKAGES=$(find . -name 'package.json' -not -path '*/node_modules/*')

            PACKAGES_JSON=$(echo "$PACKAGES" | sed 's#/package.json##' | jq -R -s -c 'split("\n")[:-1]')
            echo "Found packages = $PACKAGES_JSON"
            echo "package=$PACKAGES_JSON" >> $GITHUB_OUTPUT

            PACKAGE_NAMES=()
            PACKAGE_PATHS_MAP="{}"

            # Iterate over each package.json file
            for PACKAGE in $PACKAGES; do
                # Extract the name field from the package.json file
                if [ -f "$PACKAGE" ]; then
                    NAME=$(jq -r '.name' "$PACKAGE" | tr -d '\n' | tr -d '\r')
                    if [ "$NAME" != "null" ]; then
                        PACKAGE_NAME=$(jq -r '.name' "$PACKAGE")
                        PACKAGE_NAMES+=("$PACKAGE_NAME")
                        PACKAGE_PATH=$(echo $PACKAGE | sed 's|/package.json||')
                        PACKAGE_PATHS_MAP=$(echo $PACKAGE_PATHS_MAP | jq --arg name "$PACKAGE_NAME" --arg path "$PACKAGE_PATH" '. + {($name): $path}')
                    fi
                fi
            done

            # Convert the array of package names to a JSON array
            PACKAGE_NAMES_JSON=$(printf '%s\n' "${PACKAGE_NAMES[@]}" | jq -R -s -c 'split("\n")[:-1]')

            # New code to iterate over the package.json files and extract dependencies
            DEPENDENCIES_MAP="{"
            for PACKAGE in $PACKAGES; do
                if [ -f "$PACKAGE" ]; then
                    # Filter and collect dependencies that are in the PACKAGE_NAMES_JSON
                    FILTERED_DEPS=$(jq -r --argjson packageNames "$PACKAGE_NAMES_JSON" --argjson pathsMap "$PACKAGE_PATHS_MAP" \
                        '.dependencies | to_entries | map(select(.key as $k | $packageNames | index($k))) | map($pathsMap[.key] // "") | map(select(. != "")) | map("\"" + . + "\"") | join(",")' "$PACKAGE")
                    
                    # Format the output to match the required structure
                    if [[ $FILTERED_DEPS != "" ]]; then
                        DEPENDENCIES_MAP+="\"$(echo $PACKAGE | sed 's|/package.json||')\":[$FILTERED_DEPS],"
                    else
                        DEPENDENCIES_MAP+="\"$(echo $PACKAGE | sed 's|/package.json||')\":[],"
                    fi
                fi
            done
            # Remove the trailing comma to ensure valid JSON format
            DEPENDENCIES_MAP=${DEPENDENCIES_MAP%,}
            DEPENDENCIES_MAP+="}"

            echo "dependencies map = $DEPENDENCIES_MAP"
            echo "dependencies-map=$DEPENDENCIES_MAP" >> $GITHUB_OUTPUT
        shell: bash

  order_packages:
    needs: find_packages
    runs-on: ubuntu-latest
    env:
      json_packages: ${{ needs.find_packages.outputs.packages }}
      json_dependencies: ${{ needs.find_packages.outputs.dependencies-map }}
    outputs:
        ordered-packages: ${{ steps.ordered-packages.outputs.ordered-packages }}
    steps:
      - uses: actions/checkout@v3

      - id: ordered-packages
        name: Ordering the packages array
        run: | 
          # Convert JSON array to Bash array
          mapfile -t PACKAGES < <(echo $json_packages | jq -r '.[]')

          # Declare associative array for dependencies
          declare -A DEPENDENCIES_MAP

          # Populate the DEPENDENCIES_MAP from JSON input
          for pkg in "${PACKAGES[@]}"; do
              # Extract dependencies for the package
              dependencies=$(echo $json_dependencies | jq -r --arg pkg "$pkg" '.[$pkg] | @csv' | tr -d '"')

              # Split dependencies and populate the map
              IFS=',' read -r -a deps <<< "$dependencies"
              for dep in "${deps[@]}"; do
                  if [[ -n "$dep" ]]; then
                      DEPENDENCIES_MAP["$pkg,$dep"]=1
                  fi
              done
          done

          # Topological sort function
          function tsort() {
              local -a nodes=("${!DEPENDENCIES_MAP[@]}")
              local -A in_degree
              local -a result

              # Initialize in-degree of each package
              for pkg in "${PACKAGES[@]}"; do
                  in_degree[$pkg]=0
              done

              # Calculate in-degree
              for node in "${nodes[@]}"; do
                  IFS=',' read -r src dst <<< "$node"
                  ((in_degree[$dst]++))
              done

              # Find all nodes with in-degree 0
              local -a queue
              for pkg in "${PACKAGES[@]}"; do
                  if [[ ${in_degree[$pkg]} -eq 0 ]]; then
                      queue+=("$pkg")
                  fi
              done

              # Process the queue
              while [[ ${#queue[@]} -gt 0 ]]; do
                  local node="${queue[0]}"
                  queue=("${queue[@]:1}")
                  result=("$node" "${result[@]}")  # Reverse order by pushing to front
                  for edge in "${nodes[@]}"; do
                      IFS=',' read -r src dst <<< "$edge"
                      if [[ $src == "$node" ]]; then
                          ((in_degree[$dst]--))
                          if [[ ${in_degree[$dst]} -eq 0 ]]; then
                              queue+=("$dst")
                          fi
                      fi
                  done
              done

              echo "${result[@]}"
          }

          # Perform the topological sort
          sorted_packages=$(tsort)

          echo "$sorted_packages"

          # Ensure that the input string is handled safely
          formatted_json=$(echo "$sorted_packages" | jq -R 'split(" ") | map(select(length > 0))' | jq -c)

          # Output the formatted JSON for verification
          echo "Formatted JSON array:"
          echo "$formatted_json"

          # Properly encode JSON for GitHub Actions output
          echo "ordered-packages=$(echo "$formatted_json")" >> $GITHUB_OUTPUT

  publish-to-verdaccio:
    needs: order_packages
    runs-on: ubuntu-latest
    environment: Dev
    env:
      packages_json: ${{ needs.order_packages.outputs.ordered-packages }}
    steps:
      - uses: actions/checkout@v3

      - name: Publish packages in order to Verdaccio
        run: |
          # Convert JSON string to bash array
          readarray -t packages < <(echo $packages_json | jq -r '.[]')

          # Iterate over each package
          for PACKAGE in "${packages[@]}"; do
            echo "Processing package in directory $PACKAGE"
            
            echo "Navigate into the package directory..."
            cd $PACKAGE

            echo "Configure npm registry..." 
            echo "registry=http://${{ secrets.VERDACCIO_REGISTRY }}/" > .npmrc
            echo "//${{ secrets.VERDACCIO_REGISTRY }}/:_authToken=\"${{ secrets.VERDACCIO_TOKEN }}\"" >> .npmrc

            echo "Unpublish existing package version..."
            # npm unpublish --force || true  # Use || to handle potential failure gracefully

            echo "Install package dependencies..."
            # npm install
            
            echo "Publish the package to Verdaccio..."
            # npm publish
            
            echo "Navigate back to the root directory..."
            cd -
            
            echo
            echo
          done
        shell: bash
