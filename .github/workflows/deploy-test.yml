name: Publish Packages to Verdaccio

on:
  push:
    branches:
      - development

jobs:
  find_packages:
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.dependencies-step.outputs.package }}
      dependencies-map: ${{ steps.dependencies-step.outputs.dependencies-map }}
    steps:
      - uses: actions/checkout@v3

      - id: dependencies-step
        name: Finding packages and their dependencies in shared libraries
        run: |
            echo "Finding package.json files..."
            # Find all package.json files, excluding those in node_modules directories
            PACKAGES=$(find . -name 'package.json' -not -path '*/node_modules/*')

            PACKAGES_JSON=$(echo "$PACKAGES" | sed 's#/package.json##' | jq -R -s -c 'split("\n")[:-1]')
            echo "Found packages = $PACKAGES_JSON"
            echo "package=$PACKAGES_JSON" >> $GITHUB_OUTPUT

            PACKAGE_NAMES=()
            PACKAGE_PATHS_MAP="{}"

            # Iterate over each package.json file
            for PACKAGE in $PACKAGES; do
                # Extract the name field from the package.json file
                if [ -f "$PACKAGE" ]; then
                    NAME=$(jq -r '.name' "$PACKAGE" | tr -d '\n' | tr -d '\r')
                    if [ "$NAME" != "null" ]; then
                        PACKAGE_NAME=$(jq -r '.name' "$PACKAGE")
                        PACKAGE_NAMES+=("$PACKAGE_NAME")
                        PACKAGE_PATH=$(echo $PACKAGE | sed 's|/package.json||')
                        PACKAGE_PATHS_MAP=$(echo $PACKAGE_PATHS_MAP | jq --arg name "$PACKAGE_NAME" --arg path "$PACKAGE_PATH" '. + {($name): $path}')
                    fi
                fi
            done

            # Convert the array of package names to a JSON array
            PACKAGE_NAMES_JSON=$(printf '%s\n' "${PACKAGE_NAMES[@]}" | jq -R -s -c 'split("\n")[:-1]')

            # New code to iterate over the package.json files and extract dependencies
            DEPENDENCIES_MAP="{"
            for PACKAGE in $PACKAGES; do
                if [ -f "$PACKAGE" ]; then
                    # Filter and collect dependencies that are in the PACKAGE_NAMES_JSON
                    FILTERED_DEPS=$(jq -r --argjson packageNames "$PACKAGE_NAMES_JSON" --argjson pathsMap "$PACKAGE_PATHS_MAP" \
                        '.dependencies | to_entries | map(select(.key as $k | $packageNames | index($k))) | map($pathsMap[.key] // "") | map(select(. != "")) | map("\"" + . + "\"") | join(",")' "$PACKAGE")
                    
                    # Format the output to match the required structure
                    if [[ $FILTERED_DEPS != "" ]]; then
                        DEPENDENCIES_MAP+="\"$(echo $PACKAGE | sed 's|/package.json||')\":[$FILTERED_DEPS],"
                    else
                        DEPENDENCIES_MAP+="\"$(echo $PACKAGE | sed 's|/package.json||')\":[],"
                    fi
                fi
            done
            # Remove the trailing comma to ensure valid JSON format
            DEPENDENCIES_MAP=${DEPENDENCIES_MAP%,}
            DEPENDENCIES_MAP+="}"

            echo "dependencies map = $DEPENDENCIES_MAP"
            echo "dependencies-map=$DEPENDENCIES_MAP" >> $GITHUB_OUTPUT
        shell: bash

  order_packages:
    needs: find_packages
    runs-on: ubuntu-latest
    environment: Dev
    #env:
      #PACKAGES: ${{ needs.find_packages.outputs.packages }}
      #DEPENDENCIES_MAP: ${{ needs.find_packages.outputs.dependencies-map }}
    outputs:
        ordered-packages: ${{ steps.order-packages-step.outputs.ordered-packages }}
    steps:
      - uses: actions/checkout@v3

      - id: ordered-packages
        name: Ordering the packages array
        run: | 
          # Define the packages and an array for dependencies where each node points to its dependency
          declare -a PACKAGES=("./RabitMqClient" "./CommonMessages" "./Logger")
          declare -A DEPENDENCIES_MAP
          DEPENDENCIES_MAP["./RabitMqClient,./Logger"]=1
          DEPENDENCIES_MAP["./RabitMqClient,./CommonMessages"]=1
          DEPENDENCIES_MAP["./CommonMessages,./Logger"]=1

          # Topological sort function
          function tsort() {
              local -a nodes=("${!DEPENDENCIES_MAP[@]}")
              local -A in_degree
              local -a result

              # Initialize in-degree of each package
              for pkg in "${PACKAGES[@]}"; do
                  in_degree[$pkg]=0
              done

              # Calculate in-degree
              for node in "${nodes[@]}"; do
                  IFS=',' read -r src dst <<< "$node"
                  ((in_degree[$dst]++))
              done

              # Find all nodes with in-degree 0
              local -a queue
              for pkg in "${PACKAGES[@]}"; do
                  if [[ ${in_degree[$pkg]} -eq 0 ]]; then
                      queue+=("$pkg")
                  fi
              done

              # Process the queue
              while [[ ${#queue[@]} -gt 0 ]]; do
                  local node="${queue[0]}"
                  queue=("${queue[@]:1}")
                  result+=("$node")
                  for edge in "${nodes[@]}"; do
                      IFS=',' read -r src dst <<< "$edge"
                      if [[ $src == "$node" ]]; then
                          ((in_degree[$dst]--))
                          if [[ ${in_degree[$dst]} -eq 0 ]]; then
                              queue+=("$dst")
                          fi
                      fi
                  done
              done

              echo "${result[@]}"
          }

          # Call tsort and handle the output
          sorted_packages=$(tsort)
          echo "Sorted packages:"
          for pkg in $sorted_packages; do
              echo "$pkg"
          done

      
